question 1 :
[
  {
    $lookup: {
      from: "followers",
      localField: "user_id",
      foreignField: "follower_id",
      as: "followers"
    }
  },
  {
   $match: {
     "followers.followed_id": "user2"
   }
  },{
    $sort: {
      created_at: -1
    }
  },{
    $limit: 10 // si vous voulez afficher que les 10 derniers posts
  }
]
question 2:



// new questions
1 - 
[
  {
    $lookup: {
      from: "users",
      localField: "user_id",
      foreignField: "_id",
      as: "user"
    }
  },
  {
    $group: {
      _id: "$user_id",
      name : {$first : {$arrayElemAt :[ "$user.username",0]}},
     	numberOfComents : { $sum : {$size : "$comments" } },
      numberOfPosts: {
        $sum: 1
      }
    }
  },
  {
    $sort: {
      numberOfPosts: -1
    }
  },
  {$limit: 5}

]

2- 
[
  {
    $match: {created_at : {$gte :'2024-09-28T15:06:48.867Z'}},
  },
  {
    $group: {
      _id: "$post_id",
      comments: {
       // $push: "$$ROOT" // this will push the whole doc
        $push: "$content" // this will push the whole doc
      }
    }
  },
  {
    $lookup: {
      from: "posts",
      localField: "_id",
      foreignField: "_id",
      as: "post"
    }
  },
  {
    $project: {
      content : {$first : "$post.content"},
      comments : "$comments"
    }
  }
  
]
3-
[
  {$addFields:
    {
    likeStatus: 
    	{$cond :{
        if:{
          $in : ["user1","$likes"] // deposer le user suppose connecter
        },
        then:true,
        else:false }
      }
  	}
  },
  {
    $project: {
      likeStatus : 1,
      content:1,
      created_at:1
    }
  }

]


question 4 -  (utiliser mongosh)
let pageSize = 3 ;// nombre de commentaire voulue
let pageNumber = 2; // la page voulue

let skipNumber = (pageNumber - 1) * pageSize; // calcule des elements a depasse

[
  {
			$match : 
			{
				$expr:
				{
						$gt:['$comments',0]
				}				
			}
	},
{$skip : pageNumber},
{
	$limit:pageSize
}
]

//question 5 
//!!Attention mongoDB ne peut avoir qu'UN SEUL index de type text MAIS il vous permet de COMBINER les champs de type TEXT.
db.posts.createIndex({ title: "text", content: "text" });
//CECI va combiner l'index de recheche pour titre et contenu 
//ci vous chercher alors vous aurez des resultats pour les deux et puis vous pouvez filtrer les donn√©es non voulues

[
  {
    $match: {
      $text:{
        $search : "Amazing"
      }
    }
  },
  {
    $addFields: {
      score: {$meta: "textScore"   }
    }
  }
  ,
  {
    $sort: {
      score: -1
    }
  }
]
//ceci va vous permettre de cree des recherche comme celle que vous avez sur insta par exemple 
//MAIS SACHAIT BIEN QUE SEARCH A BESOIN PLUS DE PERFORMANCE QU'UNE SIMPLE MATCH 

//Question 6
//j'ai utiliser le reduce pour rassembler les id en une seul chaine 
[
  {
    $group: {
      _id: "$content",
      duplicate: {
        $sum: 1
      },
      postId:{$push: "$_id" }
    }
  },
  {
		$project: {
		  joinedIds : {
        $reduce:{
          input : "$postId",
          initialValue:"",
          in:{
            $cond:{
              if:{$eq:["$$value",'']},
              then:"$$this",
              else:{$concat: ["$$value", ", ", "$$this"]}
            }
          }
        }
      }
		}    
  }
]
//question 7

//visualiser la requete dans l'aggregation pipelines pour savoir si le changements pass sont aucun soucis
//apres traduiser vos requete on updateSimple

// agg
[
  {
    $match: { "_id": "post2" }
  },
  {
    $set: {
      likes: {
        $cond: {
          if: { $in: ["user2", "$likes"] },
          then: { $setDifference: ["$likes", ["user2"]] },
          else: { $concatArrays: ["$likes", ["user2"]] }
        }
      }
    }
  }
]
// update
db.posts.updateOne(
  { _id: "post2" },
  [
    {
      $set: {
        likes: {
          $cond: {
            if: { $in: ["user2", "$likes"] },
            then: { $setDifference: ["$likes", ["user2"]] },
            else: { $concatArrays: ["$likes", ["user2"]] }
          }
        }
      }
    }
  ]
);

//question 8
